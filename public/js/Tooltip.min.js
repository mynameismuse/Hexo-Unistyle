(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Tooltip", [], factory);
	else if(typeof exports === 'object')
		exports["Tooltip"] = factory();
	else
		root["Tooltip"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(1);

var tooltipType = 'tooltip-type ';
var tooltipclassName = 'Tooltip-Box ';

function drawTooltip($params, $data) {
  // 创建动态显示区域
  var $tooltipBox = document.createElement('div');
  $tooltipBox.className = tooltipclassName + $params.boxBorderColor + $params.BoxBgColor;
  $tooltipBox.innerHTML = $params.html;
  // 创建尖头
  var $arrow = document.createElement('i');
  $arrow.className = tooltipType + $params.type;
  // 创建尖头里的三角
  var $arrowInner = document.createElement('i');
  $arrowInner.className = $params.type + '-arrIner';
  var $el = document.getElementById($params.id);

  $arrow.appendChild($arrowInner);
  $tooltipBox.appendChild($arrow);
  $el.appendChild($tooltipBox);

  //tooltip方向
  tooltipDiraction($params, $el, $tooltipBox, $arrow, $arrowInner);
  // 动态css设置

  if ($params.boxBorderColor) {

    $tooltipBox.style.border = '1px solid ' + $params.boxBorderColor;
    $tooltipBox.style.backgroundColor = $params.BoxBgColor;
    $tooltipBox.style.color = $params.BoxTextColor;
  }
  $data.el = $el;
  $data.tooltipBox = $tooltipBox;
  return $data;
}
//tooltipDiraction
function tooltipDiraction($params, el, tooltip, arr, arrInner) {
  var top = void 0;
  var left = void 0;
  var padding = 10;

  switch ($params.type) {
    case 'top-left':
      if ($params.boxBorderColor) {
        arr.style.borderColor = $params.boxBorderColor + ' transparent transparent transparent';
        arrInner.style.borderColor = $params.BoxBgColor + ' transparent transparent transparent';
      }
      top = el.offsetTop - tooltip.offsetHeight - padding;
      left = el.offsetLeft;
      break;
    case 'top':
      if ($params.boxBorderColor) {
        arr.style.borderColor = $params.boxBorderColor + ' transparent transparent transparent';
        arrInner.style.borderColor = $params.BoxBgColor + ' transparent transparent transparent';
      }
      top = el.offsetTop - tooltip.offsetHeight - padding;
      if (el.offsetWidth >= tooltip.offsetWidth) {
        left = el.offsetLeft + (el.offsetWidth - tooltip.offsetWidth) / 2;
      } else {
        left = el.offsetLeft - (tooltip.offsetWidth - el.offsetWidth) / 2;
      }
      break;
    case 'top-right':
      if ($params.boxBorderColor) {
        arr.style.borderColor = $params.boxBorderColor + ' transparent transparent transparent';
        arrInner.style.borderColor = $params.BoxBgColor + ' transparent transparent transparent';
      }
      top = el.offsetTop - tooltip.offsetHeight - padding;
      if (el.offsetWidth >= tooltip.offsetWidth) {
        left = el.offsetLeft + (el.offsetWidth - tooltip.offsetWidth);
      } else {
        left = el.offsetLeft - (tooltip.offsetWidth - el.offsetWidth);
      }
      break;
    case 'right-top':
      if ($params.boxBorderColor) {
        arr.style.borderColor = 'transparent ' + $params.boxBorderColor + ' transparent transparent';
        arrInner.style.borderColor = 'transparent ' + $params.BoxBgColor + ' transparent transparent';
      }
      left = el.offsetLeft + el.offsetWidth + padding;
      top = el.offsetTop;
      break;
    case 'right':
      if ($params.boxBorderColor) {
        arr.style.borderColor = 'transparent ' + $params.boxBorderColor + ' transparent transparent';
        arrInner.style.borderColor = 'transparent ' + $params.BoxBgColor + ' transparent transparent';
      }
      left = el.offsetLeft + el.offsetWidth + padding;
      if (tooltip.offsetHeight >= el.offsetHeight) {
        top = el.offsetTop - (tooltip.offsetHeight - el.offsetHeight) / 2;
      } else {
        top = el.offsetTop + (el.offsetHeight - tooltip.offsetHeight) / 2;
      }
      break;
    case 'right-bottom':
      if ($params.boxBorderColor) {
        arr.style.borderColor = 'transparent ' + $params.boxBorderColor + ' transparent transparent';
        arrInner.style.borderColor = 'transparent ' + $params.BoxBgColor + ' transparent transparent';
      }
      left = el.offsetLeft + el.offsetWidth + padding;
      if (tooltip.offsetHeight >= el.offsetHeight) {
        top = el.offsetTop - (tooltip.offsetHeight - el.offsetHeight);
      } else {
        top = el.offsetTop + (el.offsetHeight - tooltip.offsetHeight);
      }
      break;
    case 'bottom-right':
      if ($params.boxBorderColor) {
        arr.style.borderColor = 'transparent transparent ' + $params.boxBorderColor + ' transparent';
        arrInner.style.borderColor = 'transparent transparent ' + $params.BoxBgColor + ' transparent';
      }
      top = el.offsetTop + tooltip.offsetHeight + padding;
      if (el.offsetWidth >= tooltip.offsetWidth) {
        left = el.offsetLeft + (el.offsetWidth - tooltip.offsetWidth);
      } else {
        left = el.offsetLeft - (tooltip.offsetWidth - el.offsetWidth);
      }
      break;
    case 'bottom':
      if ($params.boxBorderColor) {
        arr.style.borderColor = 'transparent transparent ' + $params.boxBorderColor + ' transparent';
        arrInner.style.borderColor = 'transparent transparent ' + $params.BoxBgColor + ' transparent';
      }
      top = el.offsetTop + tooltip.offsetHeight + padding;
      if (el.offsetWidth >= tooltip.offsetWidth) {
        left = el.offsetLeft + (el.offsetWidth - tooltip.offsetWidth) / 2;
      } else {
        left = el.offsetLeft - (tooltip.offsetWidth - el.offsetWidth) / 2;
      }
      break;
    case 'bottom-left':
      if ($params.boxBorderColor) {
        arr.style.borderColor = 'transparent transparent ' + $params.boxBorderColor + ' transparent';
        arrInner.style.borderColor = 'transparent transparent ' + $params.BoxBgColor + ' transparent';
      }
      top = el.offsetTop + tooltip.offsetHeight + padding;
      left = el.offsetLeft;
      break;
    case 'left-bottom':
      if ($params.boxBorderColor) {
        arr.style.borderColor = 'transparent transparent transparent ' + $params.boxBorderColor;
        arrInner.style.borderColor = 'transparent transparent transparent ' + $params.BoxBgColor;
      }
      left = el.offsetLeft - tooltip.offsetWidth - padding;
      if (tooltip.offsetHeight >= el.offsetHeight) {
        top = el.offsetTop - (tooltip.offsetHeight - el.offsetHeight);
      } else {
        top = el.offsetTop + (el.offsetHeight - tooltip.offsetHeight);
      }
      break;
    case 'left':
      if ($params.boxBorderColor) {
        arr.style.borderColor = 'transparent transparent transparent ' + $params.boxBorderColor;
        arrInner.style.borderColor = 'transparent transparent transparent ' + $params.BoxBgColor;
      }
      left = el.offsetLeft - tooltip.offsetWidth - padding;
      if (tooltip.offsetHeight >= el.offsetHeight) {
        top = el.offsetTop - (tooltip.offsetHeight - el.offsetHeight) / 2;
      } else {
        top = el.offsetTop + (el.offsetHeight - tooltip.offsetHeight) / 2;
      }
      break;
    case 'left-top':
      if ($params.boxBorderColor) {
        arr.style.borderColor = 'transparent transparent transparent ' + $params.boxBorderColor;
        arrInner.style.borderColor = 'transparent transparent transparent ' + $params.BoxBgColor;
      }
      left = el.offsetLeft - tooltip.offsetWidth - padding;
      top = el.offsetTop;
      break;
  }

  tooltip.style.top = top + 'px';
  tooltip.style.left = left + 'px';
}

//tooltipaction
function addAction($data) {
  $data.el.addEventListener('mouseover', function (e) {
    if (!$data.tooltipBox.className.indexOf('active') >= 0) {
      $data.tooltipBox.className += ' active';
    }
  });
  $data.el.addEventListener('mouseout', function (e) {
    if ($data.tooltipBox.className.indexOf('active') >= 0) {
      $data.tooltipBox.className = $data.tooltipBox.className.replace(' active', '');
    }
  });
}

// 校验参数
function validate($params) {
  /***校验id***/
  var $id = $params.id;
  //校验是否为字符串
  var $el = void 0;
  if (typeof $id === 'string') {
    $el = document.getElementById($id);
  } else {
    console.log('Id should be a string');
    return false;
  }
  //校验是否查询到id
  if (typeof $el === 'undefined' | null) {
    console.log('Can not find id');
    return false;
  }
  var $html = $params.html;
  if (typeof $html === 'undefined' | null) {
    console.log('Can not find html');
    return false;
  }

  /***result参数***/
  var $result = {
    id: $id,
    html: $html,
    type: $params.type,
    boxBorderColor: $params.boxBorderColor,
    BoxBgColor: $params.BoxBgColor,
    BoxTextColor: $params.BoxTextColor
  };
  return $result;
}

var Tooltip =
// 初始化对象
function Tooltip(params) {
  _classCallCheck(this, Tooltip);

  if (!params) return;
  var $data = validate(params);
  if (!$data) return;
  $data = drawTooltip(params, $data);
  addAction($data);
};

module.exports = Tooltip;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ })
/******/ ]);
});